# -*- coding: utf-8 -*-
"""Beginner02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G61cBMGOFacPKHp6RQUxzqRQCe492Cb9
"""

from google.colab import files
uploaded = files.upload()

# import required libraries
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# importing CarPrice_Assignment.csv with pandas

CarData= pd.read_csv('Car_Price.csv')

CarData.head()

# shape of the dataset
CarData.shape

# Display general information about the dataset
# This includes the count of non-null entries per column, the data type of each column, and memory usage.
CarData.info()

# Generate descriptive statistics for numerical columns
# Provide information like mean, standard deviation, min, max, and quartiles.
CarData.describe()

# Extract the car's company's name from the variable 'CarName' into the variable 'CarCompany'

company = CarData.CarName.str.split(expand=True)
CarData['CarCompany'] = company[0]

CarData.head()

# #checking the unique values under "CarCompany"
CarData.CarCompany.unique()

# replacing the mis-spelling with correct ones
CarData.replace({'alfa-romero': 'alfa-romeo',
                 'maxda': 'mazda',
                 'Nissan': 'nissan',
                 'porcshce': 'porsche',
                 'toyouta': 'toyota',
                 'vokswagen': 'volkswagen',
                 'vw': 'volkswagen'}, inplace=True)

# again checking the unique values
car_types = CarData.CarCompany.unique()
CarData.CarCompany.unique()

# Visualising 'CarCompany' variable against dependent variable 'price' via boxplot

# Create diamond shape for marker
diamond = dict(marker='d', markerfacecolor='black', markersize=6, linestyle='none')

# Create figure with a set size
plt.figure(figsize=(20, 16))

# Create a Candlestick graph
graph = sns.boxplot(data=CarData, x='CarCompany', y='price',
                    hue='CarCompany', flierprops=diamond)

# Visualising Categorical variables through boxplots
fig, ax = plt.subplots(1, 4, figsize=(20, 5))

##### FUELTYPE
sns.boxplot(data=CarData, ax=ax[0], x='fueltype', y='price',
                    hue='fueltype', flierprops=diamond)

##### CYLINDERNUMBER
sns.boxplot(data=CarData, ax=ax[1], x='cylindernumber', y='price',
                    hue='cylindernumber', flierprops=diamond)

##### ENGINELOCATION
sns.boxplot(data=CarData, ax=ax[2], x='enginelocation', y='price',
                    hue='enginelocation', flierprops=diamond)

##### DOORNUMBER
sns.boxplot(data=CarData, ax=ax[3], x='doornumber', y='price',
                    hue='doornumber', flierprops=diamond)

#creating a dict 'company price' where key = car's company and value = median of their price

# Combine data in one (by this value)[source] combine source found in [] by value passed inside ()
grouped = CarData.groupby('CarCompany')['price']

# Get the median of the values
median_prices = grouped.median()

# Convert from list to dict
company_price = median_prices.to_dict()

# output dict
company_price

# division in the buckets of low i.e. below 10000, medium i.e. range b/w 10000 and 20000 and high i.e. above 20000

# loc = to locate a cell
# CarData.loc[SELECT THIS LINE, IN THIS COLUMN] = 'low'

# mapping the company_price on the 'CarCompany' column in the dataset
for brand, price in company_price.items():
  if (price < 10000):
    range = 'low' # below 10000
  elif (price > 20000):
    range = 'high' # above 20000
  else:
    range = 'med' # 10000 to 20000

  # Update classification for each car brand based on value
  CarData.loc[CarData['CarCompany'] == brand, 'CarCompany'] = range

# checking the column's unique values
CarData.CarCompany.unique()

#creating dummy variable for categorical variables

##### One Hot Encoding
# It is a method for converting categorical variables into a binary format. = get_dummies function
# It creates new columns for each category where 1 means the category is present and 0 means it is not.
#####

CarData = pd.get_dummies(CarData) # transforms categories into numeric columns that represent them

#checking the dataset
CarData.head()

# importing required library
from sklearn.model_selection import train_test_split

##### train_test_split()
# It is separating data from the CarData randomly based on test and train size
# args:
# test_size = 30% of data used to test
# train_size = 70% of data used to train
# random_state = fixed starting point to start randomly generating numbers
#####

# remove car_ID as it's not related to the price
CarData = CarData.drop(['car_ID'], axis=1)

CarData_train, CarData_test = train_test_split(CarData, test_size=0.3, train_size=0.7, random_state=31)

#print("CarData_test: ", CarData_test)
#print("CarData_train: ", CarData_train)

# shape of the train and test sets
print(CarData_train.shape)
print(CarData_test.shape)

#importing required function for scaling
from sklearn.preprocessing import MinMaxScaler

##### MinMaxScaler
# normalize values
# change the data set so it only has values [0, 1]

scaler = MinMaxScaler(feature_range=(0, 1))

y_train = CarData_train[['price']] # training target = price
X_train =  CarData_train.drop(['price'], axis='columns') # training features without price

y_test = CarData_test[['price']] # testing target = price
X_test = CarData_test.drop(['price'], axis='columns') # testing features without price

# Scaler only changes the X (features):
X_train_scaled = pd.DataFrame(scaler.fit_transform(X_train.select_dtypes(include=['int64', 'float64']))) # learn and transform to scaler (0 and 1)
X_test_scaled = pd.DataFrame(scaler.transform(X_test.select_dtypes(include=['int64', 'float64']))) # transform to scaler only

# Train your model
from sklearn.linear_model import LinearRegression
regression = LinearRegression().fit(X_train_scaled, y_train)

# Making predictions
predicted_price = regression.predict(X_test_scaled).flatten()

# Show predictions
predicted_price

# Plotting y_test and y_pred to understand the spread.
import matplotlib.pyplot as plt
fig = plt.plot(y_test, predicted_price, 'o')
plt.xlabel("y_test")
plt.ylabel("y_pred")

from sklearn.metrics import r2_score
r2_score(y_test, predicted_price)